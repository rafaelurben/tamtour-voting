<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Voting-Result-Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex,nofollow" />

    <style>
      :root {
        --row-height: 3rem;
        --row-gap: 0.5rem;

        --animate-points-duration: 5s;
        --animate-swap-duration: 1s;

        /* These will be set dynamically */
        --max-points: 1;
        --current-position: 0;
        --target-points: 0;
        --current-points-display: '';
        --row-name-display: '';
        --row-rank-display: '';
      }

      * {
        font-family: sans-serif;
      }

      html,
      body {
        background-color: transparent;
      }

      .status-bar {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        align-items: center;
        gap: 0.5rem;

        & .status-message {
          color: red;
        }

        & .status-dot {
          height: 10px;
          width: 10px;
          border-radius: 50%;
          display: inline-block;

          &.connected {
            background-color: #4caf50;
          }

          &.disconnected {
            background-color: #f44336;
          }

          &.connecting {
            background-color: #ff9800;
          }
        }
      }

      .hidden {
        display: none;
      }

      .rows {
        position: relative;
      }

      .row {
        position: absolute;
        left: 0;
        top: calc(
          var(--current-position) * (var(--row-height) + var(--row-gap))
        );
        height: var(--row-height);
        width: 100%;
        transition: top var(--animate-swap-duration) ease-in-out;

        display: flex;
        justify-content: space-between;
        gap: 1rem;

        & .rank-container,
        & .points-container {
          width: 5rem;
        }

        & .name-and-point-bar-container {
          position: relative;
          flex-grow: 1;
          flex-basis: 50%;
          display: flex;
          flex-direction: row;
          background-color: blue;

          & .points-bar {
            position: relative;
            height: 100%;
            width: calc((var(--target-points) / var(--max-points)) * 100%);

            background-color: lightblue;
            transition: width var(--animate-points-duration) linear;
          }

          & .name-container {
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%);

            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
          }
        }

        & .name::after {
          content: var(--row-name-display);
        }

        &.revealed .rank::after {
          content: var(--row-rank-display) '.';
        }

        & .points::after {
          content: var(--current-points-display);
        }

        &.revealed {
          background-color: gray;
        }
      }
    </style>
  </head>
  <body>
    <div class="status-bar">
      <div class="status-message" id="status-message"></div>
      <div class="status-dot disconnected" id="status-dot"></div>
    </div>

    <div id="content" class="hidden">
      <div class="title" id="title"></div>
      <div class="rows" id="rows">
        <!-- Dynamic content will be rendered here -->
      </div>
    </div>

    <template id="template-row">
      <div class="row">
        <div class="rank-container">
          <span class="rank"></span>
        </div>
        <div class="name-and-point-bar-container">
          <div class="points-bar"></div>
          <div class="name-container">
            <span class="name"></span>
          </div>
        </div>
        <div class="points-container">
          <span class="points"></span>
        </div>
      </div>
    </template>

    <script>
      const $ = document.querySelector.bind(document);
      const token = new URLSearchParams(window.location.search).get('token');
      let ws;

      class ResultRenderer {
        constructor() {
          this.container = $('#content');
          this.rowsContainer = $('#rows');
          this.titleContainer = $('#title');
          this.templateRow = $('#template-row');

          this.timeoutHandles = [];

          this.clear();
        }

        show() {
          this.container.classList.remove('hidden');
        }

        hide() {
          this.container.classList.add('hidden');
        }

        clear() {
          this.hide();
          this.rowsContainer.innerHTML = '';
          this.titleContainer.innerHTML = '';

          this.maxPoints = 0;
          this.items = [];
          this.candidateIdRowMap = new Map();
          this.itemsSortedByStartNumbers = [];
          this.itemsSortedByRank = [];

          for (const handle of this.timeoutHandles) {
            clearTimeout(handle);
          }
          this.timeoutHandles = [];
        }

        render(data) {
          this.clear();
          this.titleContainer.innerText = data.title;
          this.items = data.items;

          this.itemsSortedByStartNumbers = this.items.toSorted((a, b) =>
            ('' + a.candidate.startNumber).localeCompare(
              b.candidate.startNumber,
              undefined,
              { numeric: true }
            )
          );
          this.itemsSortedByRank = this.items.toSorted(
            (a, b) => a.rank - b.rank
          );

          this.maxPoints = Math.max(...this.items.map(item => item.points), 1);
          this.rowsContainer.style.setProperty('--max-points', this.maxPoints);

          for (const item of this.items) {
            const row =
              this.templateRow.content.cloneNode(true).firstElementChild;

            row.style.setProperty(
              '--current-position',
              this.itemsSortedByStartNumbers.indexOf(item)
            );
            row.style.setProperty('--target-points', 0);
            row.style.setProperty('--current-points-display', `"0"`);
            row.style.setProperty(
              '--row-name-display',
              `"${item.candidate.name}"`
            );
            row.style.setProperty('--row-rank-display', `"${item.rank}"`);

            this.rowsContainer.appendChild(row);
            this.candidateIdRowMap.set(item.candidate.id, row);
          }
        }

        _animatePoints(elem, from, to, duration) {
          elem.style.setProperty(
            '--animate-points-duration',
            Math.round(duration) + 'ms'
          );
          elem.style.setProperty('--target-points', to);

          for (let i = from; i <= to; i++) {
            const timeoutHandle = setTimeout(
              () => {
                elem.style.setProperty('--current-points-display', `"${i}"`);
              },
              (duration / (to - from)) * (i - from)
            );
            this.timeoutHandles.push(timeoutHandle);
          }
        }

        revealLower() {
          const TOTAL_DURATION = this.items.length * 1_500; // ms

          const currMaxPoints = Math.max(
            ...this.itemsSortedByRank.slice(3).map(i => i.points),
            1
          );

          for (let i = this.itemsSortedByRank.length - 1; i >= 3; i--) {
            const item = this.itemsSortedByRank[i];
            const row = this.candidateIdRowMap.get(item.candidate.id);

            const initialPosition =
              this.itemsSortedByStartNumbers.indexOf(item);

            const duration = TOTAL_DURATION * (item.points / currMaxPoints);

            const timeoutHandle = setTimeout(() => {
              row.classList.add('revealed');
              row.style.setProperty('--current-position', item.rank - 1);

              for (let searchIndex = 0; searchIndex < i; searchIndex++) {
                const searchItem = this.itemsSortedByRank[searchIndex];
                const searchItemInitialPosition =
                  this.itemsSortedByStartNumbers.indexOf(searchItem);

                if (searchItemInitialPosition > initialPosition) {
                  const searchRow = this.candidateIdRowMap.get(
                    searchItem.candidate.id
                  );
                  const searchItemCurrentPosition = parseInt(
                    getComputedStyle(searchRow).getPropertyValue(
                      '--current-position'
                    )
                  );
                  searchRow.style.setProperty(
                    '--current-position',
                    searchItemCurrentPosition - 1
                  );
                }
              }
            }, duration + 100); // Slightly after animation ends
            this.timeoutHandles.push(timeoutHandle);

            this._animatePoints(row, 0, item.points, duration);
          }

          for (let i = 0; i < 3; i++) {
            const item = this.itemsSortedByRank[i];
            const row = this.candidateIdRowMap.get(item.candidate.id);

            this._animatePoints(row, 0, currMaxPoints, TOTAL_DURATION);
          }
        }
      }

      let resultRenderer = new ResultRenderer();

      function setState(state, message = '') {
        const statusDot = $('#status-dot');
        statusDot.classList.remove('connected', 'disconnected', 'connecting');
        statusDot.classList.add(state);
        $('#status-message').innerText = message;
      }

      function handleCommand({ action, data }) {
        switch (action) {
          case 'load_result_data':
            resultRenderer.render(data);
            break;
          case 'reveal_lower':
            resultRenderer.revealLower();
            break;
          case 'reveal_podium':
            break;
          case 'show':
            resultRenderer.show();
            break;
          case 'hide':
            resultRenderer.hide();
            break;
          case 'clear':
            resultRenderer.clear();
            break;
          default:
            console.warn('Unknown command action:', action);
        }
      }

      function connect() {
        setState('connecting');
        ws = new WebSocket(
          `ws://${location.host}/api/viewer/ws?token=${token}`
        );
        ws.addEventListener('open', () => {
          console.log('WebSocket connection opened');
        });
        ws.addEventListener('message', event => {
          const data = JSON.parse(event.data);
          console.log('Message from server:', data);

          switch (data.type) {
            case 'command':
              handleCommand(data);
              break;
            case 'error':
              console.error('Error from server:', data.message);
              break;
            case 'connected':
            case 'heartbeat':
              setState('connected');
              break;
            default:
              console.warn('Unknown message type:', data.type);
          }
        });
        ws.addEventListener('close', event => {
          console.log(
            'WebSocket connection closed! Reconnecting in 5 seconds...',
            event
          );
          setState('disconnected', event.reason);
          setTimeout(connect, 5000);
        });
      }

      window.addEventListener('load', () => {
        if (!token) {
          setState('disconnected', 'No token provided');
          return;
        }
        connect();
      });
    </script>
  </body>
</html>
